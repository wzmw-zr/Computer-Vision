# 非极大值抑制 (Non-Maximum Suppression, NMS)

非极大值抑制，即抑制不是最大值的元素，可以理解为局部最大搜索。这个局部即邻域，邻域有两个参数可变，邻域的维数和邻域的大小。

在目标检测算法中，使用bounding box，通过网络，获得bounding box的坐标，分数等信息，但是**bounding box通常会和其他很多窗口有包含获得大部分交叉的关系**，这时就需要**使用NMS选择那些邻域中分数最高(和指定bounding box的IOU)的bounding box，并且抑制那些分数低的bounding box**。

> **IOU高的表明这些bounding box都有极大概率为同一个目标**，所以筛出来，**被抑制的bounding box通常是其他目标的bounding box**。

> 需要注意的是：==**Non-Maximum Suppression一次处理一个类别，如果有N个类别，Non-Maximum Suppression就需要执行N次**==。对每个类执行一次NMS就行。

## 一、NMS算法流程(单类别)

**输入**：N个bounding box，N个score，threshold。

**输出**：目标bounding boxes。

**过程**：

1. 将bounding box按照score从大到小排序。
2. + 选择最大score的bounding box，计算其和剩下bounding box的IOU，留下IOU小于threshold的，如果没有的话就跳出循环。
   + 更新剩下的bounding box。



代码：

```python
def nms(bboxes: torch.Tensor, scores: torch.Tensor, threshold=0.5):
    """ Non-Maximum Suppression
    @params bboxes(tensor) [N, 4]: coordinates of bounding boxes
    @params scores(tensor) [N, ]: the scores of the bounding boxes
    @params threshold(float): the threshold for NMS
    """
    x1 = bboxes[:, 0]
    y1 = bboxes[:, 1]
    x2 = bboxes[:, 2]
    y2 = bboxes[:, 3]
    areas = (x2 - x1 + 1) * (y2 - y1 + 1)

    _, order = scores.sort(dim=0, descending=True)
    keep = list()
    while order.numel() > 0:
        i = order[0]
        keep.append(i)
        if order.numel() == 1:
            break
        xx1 = x1[order[1:]].clamp(min=x1[i])
        xy1 = y1[order[1:]].clamp(min=y1[i])
        xx2 = x2[order[1:]].clamp(max=x2[i])
        xy2 = y2[order[1:]].clamp(max=y2[i])
        w = (xx2 - xx1).clamp(min=0)
        h = (xy2 - xy1).clamp(min=0)
        inter = w * h
        iou = inter / (areas[i] + areas[order[1:]] - inter)
        indices = (iou <= threshold).nonzero().squeeze()
        if indices.numel() == 0:
            break
        order = order[indices + 1] # 因为iou长度比order小1,所以要+1获得正确的索引
    return torch.LongTensor(keep)
```

